<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D æ‰‹åŠ¿ç²’å­äº¤äº’ - æ…¢é€Ÿè‡ªæ—‹ä¸éšè—UI</title>
    <style>
        :root {
            --primary-color: #ff00cc; /* é»˜è®¤ç²‰è‰² */
            --glass-bg: rgba(20, 20, 30, 0.7);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }

        #video-container {
            display: none;
        }

        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px; 
            padding: 20px;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            z-index: 100;
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
        }

        #ui-panel.hidden {
            transform: translateX(calc(-100% - 30px)); /* éšè—åˆ°å·¦ä¾§å±å¹•å¤– */
            opacity: 0;
        }

        h1 {
            font-size: 18px;
            margin: 0 0 15px 0;
            display: flex;
            align-items: center;
            gap: 10px;
            text-shadow: 0 0 10px rgba(255, 0, 204, 0.3);
        }

        .status-dot {
            width: 10px;
            height: 10px;
            background: #ff4444;
            border-radius: 50%;
            box-shadow: 0 0 8px #ff4444;
            transition: all 0.3s;
        }
        .status-dot.active {
            background: var(--primary-color);
            box-shadow: 0 0 12px var(--primary-color), 0 0 20px var(--primary-color);
        }
        .status-dot.exploding {
            background: #ffffff;
            box-shadow: 0 0 15px #ffffff, 0 0 30px #ffffff;
        }

        .control-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-size: 12px;
            color: #aaa;
            margin-bottom: 8px;
        }

        .shape-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        /* é¢œè‰²é€‰æ‹©å™¨æ ·å¼ */
        .color-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: flex-start;
        }

        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .color-option.active {
            border-color: white;
            box-shadow: 0 0 10px white, 0 0 15px currentColor;
        }

        button {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            color: white;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--primary-color);
        }

        button.active {
            background: var(--primary-color);
            color: white;
            font-weight: bold;
            box-shadow: 0 0 15px rgba(255, 0, 204, 0.4);
        }
        
        /* éšè—/å…¨å±æŒ‰é’®å®¹å™¨ */
        #top-right-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            gap: 10px;
        }

        .control-button {
            background: var(--glass-bg);
            backdrop-filter: blur(5px);
            border: 1px solid var(--glass-border);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--primary-color);
            font-size: 24px;
            z-index: 200;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(255, 0, 204, 0.5);
            text-align: center;
        }
    </style>
    
    <script src="https://unpkg.com/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">
        æ­£åœ¨åŠ è½½è§†è§‰æ¨¡å‹...<br>
        <span style="font-size: 14px; color: #aaa;">è¯·å…è®¸æ‘„åƒå¤´æƒé™</span>
    </div>

    <div id="video-container">
        <video class="input_video"></video>
    </div>

    <div id="top-right-controls">
        <button id="toggle-ui-btn" class="control-button" title="éšè—/æ˜¾ç¤ºæ§åˆ¶é¢æ¿">â–</button>
        <button id="fullscreen-btn" class="control-button" title="å…¨å±æ¨¡å¼">â›¶</button>
    </div>
    
    <div id="ui-panel">
        <h1>
            <div class="status-dot" id="status-dot"></div>
            ç²’å­æ§åˆ¶å™¨
        </h1>
        
        <div class="control-group">
            <label>å½¢çŠ¶æ¨¡ç‰ˆ</label>
            <div class="shape-grid">
                <button class="shape-btn active" data-shape="heart">â¤ çˆ±å¿ƒ</button>
                <button class="shape-btn" data-shape="saturn">ğŸª åœŸæ˜Ÿ</button>
                <button class="shape-btn" data-shape="flower">ğŸŒ¸ èŠ±æœµ</button>
                <button class="shape-btn" data-shape="fireworks">ğŸ† çƒŸèŠ±</button>
            </div>
        </div>

        <div class="control-group">
            <label>ç²’å­é¢œè‰²</label>
            <div class="color-grid" id="color-options-container">
                </div>
        </div>

        <div class="control-group">
            <label>æ‰‹åŠ¿è¯´æ˜</label>
            <div style="font-size: 12px; color: #888; line-height: 1.6;">
                ğŸ¤ <b>å•æŒ‡æåˆ</b>: ç¼©æ”¾æ§åˆ¶<br>
                ğŸ– <b>ç”¨åŠ›å¼ å¼€äº”æŒ‡</b>: <span style="color: white; font-weight: bold; text-shadow: 0 0 5px white;">æ¾æ•£æ¨¡å¼</span>
            </div>
        </div>
    </div>

    <script>
        // --- é¢œè‰²é…ç½® ---
        const PRESET_COLORS = {
            'Elysia Pink': '#ff00cc',
            'Sky Blue': '#00bfff',
            'Mint Green': '#00ff7f',
            'Sun Gold': '#ffc300',
            'Pure White': '#ffffff',
            'Deep Purple': '#8a2be2'
        };
        const DEFAULT_COLOR_HEX = PRESET_COLORS['Elysia Pink'];
        const AUTO_ROTATION_SPEED = 0.001; // æ…¢é€Ÿè‡ªæ—‹ï¼Œä½ è¦æ±‚çš„ï¼

        let scene, camera, renderer, particles;
        let geometry, material;
        const PARTICLE_COUNT = 15000;
        let currentShape = 'heart';
        let targetPositions = [];
        
        let handScale = 1.0; 
        let baseSize = 0.05;
        let isExploding = false;
        
        let userColor = new THREE.Color(DEFAULT_COLOR_HEX); 
        const explodeColor = new THREE.Color(0xffffff);
        let currentColor = new THREE.Color(DEFAULT_COLOR_HEX);

        const Shapes = {
            heart: () => {
                const arr = [];
                for(let i=0; i<PARTICLE_COUNT; i++) {
                    let t = Math.random() * Math.PI * 2;
                    let r = Math.sqrt(Math.random()); 
                    let x = 16 * Math.pow(Math.sin(t), 3);
                    let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    let z = (Math.random() - 0.5) * 4 * r;
                    arr.push(x * r * 0.5, y * r * 0.5, z);
                }
                return arr;
            },
            saturn: () => {
                const arr = [];
                const sphereCount = Math.floor(PARTICLE_COUNT * 0.6);
                const ringCount = PARTICLE_COUNT - sphereCount;
                for(let i=0; i<sphereCount; i++) {
                    const phi = Math.acos( -1 + ( 2 * i ) / sphereCount );
                    const theta = Math.sqrt( sphereCount * Math.PI ) * phi;
                    const r = 6;
                    arr.push(r * Math.cos(theta) * Math.sin(phi), r * Math.sin(theta) * Math.sin(phi), r * Math.cos(phi));
                }
                for(let i=0; i<ringCount; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const r = 9 + Math.random() * 5; 
                    arr.push(r * Math.cos(theta), (Math.random()-0.5) * 0.5, r * Math.sin(theta));
                }
                return arr;
            },
            flower: () => {
                const arr = [];
                const k = 3; 
                for(let i=0; i<PARTICLE_COUNT; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const r = Math.cos(k * theta) * 10;
                    const x = r * Math.cos(theta);
                    const y = r * Math.sin(theta);
                    const z = (Math.random() - 0.5) * 4 + Math.sin(r)*2;
                    arr.push(x, y, z);
                }
                return arr;
            },
            fireworks: () => {
                const arr = [];
                for(let i=0; i<PARTICLE_COUNT; i++) {
                    const u = Math.random();
                    const v = Math.random();
                    const theta = 2 * Math.PI * u;
                    const phi = Math.acos(2 * v - 1);
                    const r = 5 + Math.random() * 10;
                    arr.push(r * Math.sin(phi) * Math.cos(theta), r * r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
                }
                return arr;
            }
        };

        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            for(let i=0; i<PARTICLE_COUNT*3; i++) {
                positions[i] = (Math.random() - 0.5) * 100;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            targetPositions = Shapes[currentShape]();

            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
            material = new THREE.PointsMaterial({
                color: userColor,
                size: baseSize,
                map: sprite,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            const positions = particles.geometry.attributes.position.array;
            
            const moveSpeed = isExploding ? 0.06 : 0.05;

            // --- ç²’å­è‡ªæ—‹ (æ–°è¦æ±‚) ---
            // æ— è®ºæ˜¯å¦æœ‰æ‰‹åŠ¿è¾“å…¥ï¼Œéƒ½ä»¥ææ…¢çš„é€Ÿåº¦è‡ªæ—‹
            particles.rotation.y += AUTO_ROTATION_SPEED;
            
            // é¢œè‰²å¤„ç†
            if (isExploding) {
                currentColor.lerp(explodeColor, 0.1);
            } else {
                currentColor.lerp(userColor, 0.1);
            }
            material.color.set(currentColor);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                let tx, ty, tz;

                if (isExploding) {
                    const scatterRadius = 25; 
                    tx = Math.sin(i * 0.13) * scatterRadius + (Math.random() - 0.5) * 2;
                    ty = Math.cos(i * 0.17) * scatterRadius + (Math.random() - 0.5) * 2;
                    tz = Math.sin(i * 0.19) * scatterRadius + (Math.random() - 0.5) * 2;
                } else {
                    tx = targetPositions[ix] * handScale;
                    ty = targetPositions[iy] * handScale;
                    tz = targetPositions[iz] * handScale;
                }

                positions[ix] += (tx - positions[ix]) * moveSpeed;
                positions[iy] += (ty - positions[iy]) * moveSpeed;
                positions[iz] += (tz - positions[iz]) * moveSpeed;
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
            
            const sizeFactor = isExploding ? 1.0 : (0.5 + handScale * 0.5);
            material.size = baseSize * sizeFactor * 5;
            
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        const videoElement = document.getElementsByClassName('input_video')[0];
        
        function onResults(results) {
            const loading = document.getElementById('loading');
            if(loading) loading.style.display = 'none';

            const statusDot = document.getElementById('status-dot');
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const wrist = landmarks[0];

                // --- 1. ä¼¸ç›´æ£€æµ‹ (æ›´ä¸¥æ ¼) ---
                function isExtended(tipIdx, pipIdx) {
                    const tip = landmarks[tipIdx];
                    const pip = landmarks[pipIdx];
                    const dTip = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
                    const dPip = Math.hypot(pip.x - wrist.x, pip.y - wrist.y);
                    return dTip > dPip * 1.25;
                }

                const thumbUp = isExtended(4, 2);
                const indexUp = isExtended(8, 6);
                const middleUp = isExtended(12, 10);
                const ringUp = isExtended(16, 14);
                const pinkyUp = isExtended(20, 18);

                // --- 2. æ‰‹æŒ‡å¼ å¼€åº¦æ£€æµ‹ (æ¾æ•£æ¨¡å¼) ---
                const spreadDist = Math.hypot(
                    landmarks[8].x - landmarks[20].x,
                    landmarks[8].y - landmarks[20].y
                );
                const palmSize = Math.hypot(
                    landmarks[0].x - landmarks[9].x,
                    landmarks[0].y - landmarks[9].y
                );
                
                const isSpread = spreadDist > palmSize * 0.9;

                if (thumbUp && indexUp && middleUp && ringUp && pinkyUp && isSpread) {
                    isExploding = true;
                    statusDot.className = 'status-dot active exploding';
                    handScale = 1.1; 
                } else {
                    isExploding = false;
                    statusDot.className = 'status-dot active';
                    
                    // --- 3. æåˆç¼©æ”¾æ£€æµ‹ ---
                    const thumbTip = landmarks[4];
                    const indexTip = landmarks[8];
                    const distance = Math.sqrt(
                        Math.pow(thumbTip.x - indexTip.x, 2) +
                        Math.pow(thumbTip.y - indexTip.y, 2)
                    );

                    const minDist = 0.02;
                    const maxDist = 0.2;
                    let normalized = (distance - minDist) / (maxDist - minDist);
                    normalized = Math.max(0, Math.min(1, normalized)); 

                    const targetScale = 0.5 + normalized * 2.0;
                    handScale += (targetScale - handScale) * 0.1;
                }

            } else {
                statusDot.className = 'status-dot';
                isExploding = false;
                handScale += (1.0 - handScale) * 0.05;
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });
        cameraUtils.start();

        // --- UI äº¤äº’é€»è¾‘ ---
        
        // 1. å½¢çŠ¶æŒ‰é’®
        document.querySelectorAll('.shape-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                currentShape = e.target.dataset.shape;
                targetPositions = Shapes[currentShape]();
            });
        });

        // 2. é¢œè‰²é€‰æ‹©å™¨
        const colorContainer = document.getElementById('color-options-container');

        Object.entries(PRESET_COLORS).forEach(([name, hex]) => {
            const div = document.createElement('div');
            div.className = 'color-option';
            div.style.backgroundColor = hex;
            div.title = name;
            div.setAttribute('data-color', hex);
            
            if (hex === DEFAULT_COLOR_HEX) {
                div.classList.add('active');
            }

            div.addEventListener('click', () => {
                document.querySelectorAll('.color-option').forEach(c => c.classList.remove('active'));
                div.classList.add('active');
                
                userColor.set(hex); 
                document.documentElement.style.setProperty('--primary-color', hex);
            });
            colorContainer.appendChild(div);
        });
        
        // 3. å…¨å±æŒ‰é’®
        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.body.requestFullscreen().catch(err => alert(`æ— æ³•è¿›å…¥å…¨å±: ${err.message}`));
            } else {
                document.exitFullscreen();
            }
        });

        // 4. éšè—/æ˜¾ç¤º UI æŒ‰é’® (æ–°åŠŸèƒ½)
        const uiPanel = document.getElementById('ui-panel');
        const toggleUiBtn = document.getElementById('toggle-ui-btn');

        toggleUiBtn.addEventListener('click', () => {
            const isHidden = uiPanel.classList.toggle('hidden');
            // æ ¹æ®çŠ¶æ€åˆ‡æ¢æŒ‰é’®å›¾æ ‡
            toggleUiBtn.innerText = isHidden ? 'â•' : 'â–';
            toggleUiBtn.title = isHidden ? 'æ˜¾ç¤ºæ§åˆ¶é¢æ¿' : 'éšè—æ§åˆ¶é¢æ¿';
        });


        initThree();

    </script>
</body>
</html>